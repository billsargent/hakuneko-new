<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../../polymer/lib/elements/dom-if.html">
<!-- <link rel="import" href="../../iron-list/iron-list.html"> -->
<link rel="import" href="connectors.html">
<link rel="import" href="bookmarks.html">
<link rel="import" href="status.html">
<link rel="import" href="theme.html">

<dom-module id="hakuneko-mangas">

    <template>
        <style include="theme"></style>
        <style>
            :host {
                display: flex;
                flex-direction: column;
                padding: 0.5em;
                background-color: var(--manga-control-background-color);
            }
            .separator {
                border-bottom: var(--manga-control-separator);
            }
            .header {
                flex: 0;
                font-weight: bold;
                font-size: 1.25em;
                padding: 0.25em;
            }
            #paste {
                position: absolute;
                z-index: -9999;
                height: 0em;
                width: 0em;
                opacity: 0;
            }
            .filter {
                flex: 0;
                width: 100%;
            }
            .notification {
                padding: 0.5em;
                font-weight: bold;
                text-align: center;
                line-height: 150%;
                background-color: var(--manga-list-notification-color);
                border: var(--manga-list-notification-border);
            }
            .list {
                flex: 1;
                margin-top: 0.5em;
                margin-bottom: 0.5em;
                border: var(--manga-list-border);
                background-color: var(--manga-list-background-color);
                overflow-y: scroll;
                white-space: nowrap;
                list-style-type: none;
                padding: 0.25em;
            }
            .manga {
                overflow-x: hidden;
                text-overflow: ellipsis;
                cursor: pointer;
            }
            .manga:hover {
                background-color: var(--manga-list-highlighted);
            }
            .focus {
                background-color: var(--manga-list-selected) !important;
            }
            .button {
                cursor: pointer;
            }
            .refresh {
                cursor: pointer;
                color: var(--manga-refresh-button-color);
                text-shadow: var(--manga-refresh-button-shadow);
            }
            .disabled {
                color: var(--manga-button-disabled-color);
                cursor: progress !important; /* wait */
            }
            .footer {
                flex: 0;
            }
        </style>
        <div class="header separator">
            <table border="0" cellpadding="0" cellspacing="0" width="100%">
                <tr>
                    <td>
                        Manga List
                    </td>
                    <td width="1">
                        <span style="display: inline-block; white-space: nowrap;">
                            <i class="fas fa-fw fa-globe button" on-click="onOpenConnectorWebsiteClick" title="Open the website of the current connector in a new window to handle Cloudflare authentication"></i>
                            <i class="fas fa-fw fa-download button" on-click="onDownloadAllMangasClick" title="Click to download all mangas currently shown in the filtered list, including all their chapters"></i>
                            <input id="paste" />
                            <i class="fas fa-fw fa-paste button" on-click="onPasteClick" title="Click to paste manga links from the clipboard (CTRL + V)"></i>
                        </span>
                    </td>
                </tr>
            </table>
        </div>
        <table class="filter separator">
            <tr>
                <td>
                    <i class="fas fa-fw fa-plug fa-flip-horizontal" title="Select a website from which the manga list should be shown"></i>
                </td>
                <td style="width: 100%;">
                    <hakuneko-connectors selected-connector="{{ selectedConnector }}"></hakuneko-connectors>
                </td>
                <td>
                    <i class$="fas fa-fw fa-sync [[ getRefreshClass(selectedConnector.isUpdating) ]] refresh" on-click="onUpdateMangaListClick" title$="Synchronize local manga list with online list from &lt;[[ selectedConnector.label ]]&gt;"></i>
                </td>
            </tr>
            <tr>
                <td>
                    <i class="fas fa-fw fa-search" title="Enter a pattern (at least 3 characters) to filter the manga list by their titles"></i>
                </td>
                <td>
                    <input type="text" value="{{ mangaPattern::input }}"/>
                </td>
                <td>
                    <hakuneko-bookmarks selected-manga="{{ selectedManga }}"></hakuneko-bookmarks>
                </td>
            </tr>
        </table>
        <ul class="list" >
            <template is="dom-if" if="[[ existMangasForValidConnector(selectedConnector, mangaList.length) ]]">                        
                <li class="notification">
                    Manga list is loading or empty<br>
                    Click &nbsp;<i class$="fas fa-sync [[ getRefreshClass(selectedConnector.isUpdating) ]] refresh" on-click="onUpdateMangaListClick" title$="Synchronize local manga list with online list from &lt;[[ selectedConnector.label ]]&gt;"></i>&nbsp;
                    button to update list<br/>
                    <br/>
                    <i class="fas fa-info-circle"></i> Some connectors are slow<br/>
                    and may take more than 10mins<br/>
                    If the icon is still spinning,<br/>
                    it's still working<br/>
                    <br/>
                    To check the activity press F12<br/>
                    and go to the network tab
                </li>
            </template>
            <template is="dom-repeat" items="[[ mangaList ]]" filter="[[ filterMangas(mangaPattern) ]]" rendered-item-count="{{ mangaFilteredCount }}">
                <li class$="manga [[ item.status ]] [[ getMangaClass(selectedManga, item.id) ]]" title$="[[ item.title ]]&#10;[[ item.connector.label ]]" on-click="onMangaClicked">[[ item.title ]]</li>
            </template>
        </ul>
        <!-- https://github.com/PolymerElements/iron-list/issues/536 -->
        <!--
        <iron-list class="list" items="[[ filteredMangas(mangaList,mangaPattern) ]]">
            <template>
                <div class$="manga [[ item.status ]] [[ getMangaClass(selectedManga, item.id) ]]" title$="[[ item.title ]]&#10;[[ item.connector.label ]]" on-click="onMangaClicked">[[ item.title ]]</div>
            </template>
        </iron-list>
        -->
        <div class="footer">
            <hakuneko-status id="status" message="Mangas: [[ mangaFilteredCount ]] / [[ mangaList.length ]]"></hakuneko-status>
        </div>
    </template>

    <script>
        /** @polymerElement */
        class HakunekoMangas extends Polymer.Element {
            /**
             *
             */
            static get is() {
                return 'hakuneko-mangas';
            }

            /**
             *
             */
            static get properties() {
                return {
                    selectedConnector: {
                        type: Object,
                        value: undefined,
                        notify: true, // enable upward data flow,
                        //readOnly: true, // prevent downward data flow
                        observer: 'onSelectedConnectorChanged'
                    },
                    selectedManga: {
                        type: Object,
                        value: undefined,
                        notify: true, // enable upward data flow,
                        //readOnly: true, // prevent downward data flow
                        observer: 'onSelectedMangaChanged'
                    }
                };
            }

            /**
             *
             */
            ready() {
                super.ready();
                // the bookmark connector which is required for some exceptional handling
                this.bookmarkConnectorID = 'bookmarks';
                // currently active manga list
                this.mangaList = this['mangaList'];
                // register callbacks for published events
                document.addEventListener( EventListener.onMangaStatusChanged, this.onMangaStatusChanged.bind( this ) );
                Engine.BookmarkManager.addEventListener( 'changed', this.onBookmarksChanged.bind( this ) );
            }

            /**
             * Observer will be executed, whenever the 'selectedConnector' is changed.
             */
            onSelectedConnectorChanged( connector ) {
                this.set( 'selectedManga', undefined );
                if( !connector ) {
                    this.set( 'mangaList', undefined );
                    return;
                }
                let statusID = this.$.status.addToQueue( 'Loading manga list (' + connector.label + ')' );
                // set to undefined when switching manga list prevents a bug in iron-list (high CPU usage) 
                this.set( 'mangaList', [] );
                connector.getMangas( ( error, mangas ) => {
                    // check if executing connector is still the selected connector (visible)
                    if( connector === this.selectedConnector ) {
                        this.set( 'mangaList', mangas );
                    }
                    this.$.status.removeFromQueue( statusID );
                } );
            }

            /**
             * Event listener attached to the corresponding refresh button element.
             */
            onUpdateMangaListClick( e ) {
                let connector = this.selectedConnector;
                if( !connector || connector.isUpdating ) {
                    return;
                }
                let statusID = this.$.status.addToQueue( 'Updating manga list (' + connector.label + ')' );
                connector.updateMangas( ( error, mangas ) => {
                    // check if executing connector is still the selected connector (visible)
                    if( connector === this.selectedConnector ) {
                        if( !error ) {
                            this.set( 'mangaList', mangas );
                        }
                        // trigger update for refresh button style (update completed)
                        this.notifyPath( 'selectedConnector.isUpdating' );
                    }
                    this.$.status.removeFromQueue( statusID );
                    if( error ) {
                        alert('Failed to update manga list for ' + connector.label + '\n\n' + error.message, 'HakuNeko - ' + connector.label, 'error');
                    }
                } );
                // trigger update for refresh button style (update started)
                this.notifyPath( 'selectedConnector.isUpdating' );
            }

            /**
             *
             */
            existMangasForValidConnector( connector, mangaCount ) {
                return (connector && connector.id !== this.bookmarkConnectorID && ( !mangaCount || mangaCount < 1 ) );
            }

            /**
             * Event listener attached to the corresponding <li> element.
             * When the element is clicked, the corresponding manga from 'mangaList' will be assigned to 'selectedManga'.
             */
            onMangaClicked( e ) {
                this.set( 'selectedManga', e.model.item );
                document.dispatchEvent(new CustomEvent(EventListener.onSelectManga, { detail: e.model.item }));
            }

            /**
             * Observer will be executed, whenever the 'selectedManga' is changed.
             */
            onSelectedMangaChanged( manga ) {
                //
            }

            /**
             *
             */
            getMangaClass( selectedManga, id ) {
                return ( !selectedManga || selectedManga.id !== id ? '' : 'focus' );
            }

            /**
             *
             */
            getRefreshClass( isUpdating ) {
                return ( isUpdating ? 'fa-pulse disabled' : '' );
            }

            /**
             *
             */
            filterMangas( pattern ) {
                let isLatin = /^[a-zA-Z0-9]+$/.test( pattern );
                let threshold = isLatin ? 3 : 2;
                if( !pattern || pattern.length < threshold ) {
                    return null;
                }
                let p = pattern.toLowerCase();
                return ( manga ) => {
                    return ( manga.title.toLowerCase().includes( p ) || manga.connector.label.toLowerCase().includes( p ) );
                };
            }

            /**
             * 
             */
            onMangaStatusChanged( e ) {
                let manga = e.detail;
                if( !this.mangaList
                    || !this.selectedConnector
                    || (this.selectedConnector.id !== this.bookmarkConnectorID && this.selectedConnector.id !== manga.connector.id)
                ) {
                    return;
                }
                let index = this.mangaList.findIndex( ( item ) => {
                    // mangas may be different objects (synchronizing connector list) but still be equivalent
                    // => comparing ids instead of comparing the objects directly
                    return ( item.id === manga.id );
                });
                if( index > -1 ) {
                    this.notifyPath( 'mangaList.' + index + '.status' );
                }
            }

            /**
             *
             */
            onBookmarksChanged( e ) {
                if( this.selectedConnector.id === this.bookmarkConnectorID ) {
                    this.onSelectedConnectorChanged( this.selectedConnector )
                }
            }

            /**
             *
             */
            onPasteClick(evt) {
                let clipboardConnector = Engine.Connectors.find(connector => connector.id === 'clipboard');
                if(true/*clipboard seems to have valid manga links*/) {
                    this.set('selectedConnector', clipboardConnector);
                    this.onUpdateMangaListClick(evt);
                }
            }

            /**
             * Opens the website of the current connector in a new window to handle Cloudflare authentication
             */
            onOpenConnectorWebsiteClick(evt) {
                if (!this.selectedConnector) {
                    alert('No connector selected!');
                    return;
                }

                // Special handling for bookmarks and clipboard connectors
                if (this.selectedConnector.id === this.bookmarkConnectorID || this.selectedConnector.id === 'clipboard') {
                    alert('This connector does not have a website to open.');
                    return;
                }

                // Get the base URL of the connector
                let url = '';
                try {
                    // Most connectors should have a url property
                    if (this.selectedConnector.url) {
                        url = this.selectedConnector.url;
                    }
                    // As a fallback, try the baseURL if it exists
                    else if (this.selectedConnector.baseURL) {
                        url = this.selectedConnector.baseURL;
                    }
                    // As a second fallback, try to use the URI from the first manga if available
                    else if (this.mangaList && this.mangaList.length > 0 && this.mangaList[0].uri) {
                        // Extract domain from URI
                        let uri = this.mangaList[0].uri;
                        let match = uri.match(/^(?:https?:\/\/)?([^\/]+)/i);
                        if (match && match[0]) {
                            url = match[0];
                        }
                    }

                    if (!url) {
                        throw new Error('Could not determine website URL for this connector.');
                    }

                    // Ensure URL has a protocol
                    if (!url.startsWith('http')) {
                        url = 'https://' + url;
                    }

                    // Based on the logs, Cloudflare requires cross-origin isolation features that
                    // Electron lacks. Always use the system browser which has full security feature support.
                    let importCookiesConfirmed = confirm('Opening website in your default browser. Please complete any Cloudflare challenges, then return to HakuNeko and click OK on this dialog to import cookies.\n\nWould you like to import cookies after authentication?');
                    
                    // Store the URL for later cookie import
                    this._lastOpenedConnectorUrl = url;
                    
                    // Use the electron shell to open in the default system browser
                    try {
                        if (window.electron && window.electron.shell) {
                            window.electron.shell.openExternal(url);
                        } else if (window.require) {
                            // Fallback for older Electron versions
                            const { shell } = window.require('electron');
                            shell.openExternal(url);
                        } else {
                            // Last resort fallback to window.open 
                            window.open(url, '_blank');
                        }
                        
                        // If user wants to import cookies after authentication
                        if (importCookiesConfirmed) {
                            // Wait for user to complete authentication in browser
                            setTimeout(() => {
                                this._importCookiesFromClipboard(url);
                            }, 500);
                        }
                    } catch (e) {
                        console.error('Failed to open external browser:', e);
                        alert('Error opening browser: ' + e.message + '\nPlease manually visit: ' + url);
                    }
                } catch (error) {
                    alert('Error opening website: ' + error.message);
                }
            }

            /**
             * Extracts cookies from clipboard text and imports them into Electron's session
             * This is useful for getting Cloudflare cookies (especially cf_clearance) from the system browser
             */
            async _importCookiesFromClipboard(url) {
                try {
                    // Create instructions for the user
                    let instructions = 
                        "Please follow these steps to import cookies:\n\n" +
                        "1. In your browser, navigate to the website you just visited\n" +
                        "2. Open browser DevTools (F12 or right-click > Inspect)\n" +
                        "3. Go to the 'Application' tab (Chrome) or 'Storage' tab (Firefox)\n" +
                        "4. Under 'Storage', expand 'Cookies' and click on the website\n" +
                        "5. Find the 'cf_clearance' cookie (needed for Cloudflare protection)\n" +
                        "6. Copy its value (we'll use it in the next step)";
                    
                    // Get domain from URL for cookie setting
                    const domain = new URL(url).hostname;
                    
                    // Show the instructions
                    await alert(instructions);
                    
                    // Use an input dialog via an overlay element
                    // Create a modal dialog with inputs
                    let overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    overlay.style.zIndex = '9999';
                    overlay.style.display = 'flex';
                    overlay.style.justifyContent = 'center';
                    overlay.style.alignItems = 'center';
                    
                    let dialog = document.createElement('div');
                    dialog.style.backgroundColor = '#fff';
                    dialog.style.padding = '20px';
                    dialog.style.borderRadius = '5px';
                    dialog.style.maxWidth = '500px';
                    dialog.style.width = '80%';
                    
                    let heading = document.createElement('h3');
                    heading.textContent = 'Import Cookie';
                    heading.style.marginTop = '0';
                    
                    let nameLabel = document.createElement('div');
                    nameLabel.textContent = 'Cookie Name:';
                    
                    let nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = 'cf_clearance';
                    nameInput.style.width = '100%';
                    nameInput.style.marginBottom = '10px';
                    nameInput.style.boxSizing = 'border-box';
                    
                    let valueLabel = document.createElement('div');
                    valueLabel.textContent = 'Cookie Value:';
                    
                    let valueInput = document.createElement('input');
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Paste the cookie value here';
                    valueInput.style.width = '100%';
                    valueInput.style.marginBottom = '20px';
                    valueInput.style.boxSizing = 'border-box';
                    
                    let buttonContainer = document.createElement('div');
                    buttonContainer.style.display = 'flex';
                    buttonContainer.style.justifyContent = 'flex-end';
                    
                    let cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.style.marginRight = '10px';
                    
                    let saveButton = document.createElement('button');
                    saveButton.textContent = 'Save';
                    
                    buttonContainer.appendChild(cancelButton);
                    buttonContainer.appendChild(saveButton);
                    
                    dialog.appendChild(heading);
                    dialog.appendChild(nameLabel);
                    dialog.appendChild(nameInput);
                    dialog.appendChild(valueLabel);
                    dialog.appendChild(valueInput);
                    dialog.appendChild(buttonContainer);
                    
                    overlay.appendChild(dialog);
                    document.body.appendChild(overlay);
                    
                    // Focus the value input for easy pasting
                    valueInput.focus();
                    
                    // Return a promise that resolves when user submits the form
                    let cookieName, cookieValue;
                    
                    await new Promise((resolve, reject) => {
                        cancelButton.addEventListener('click', () => {
                            document.body.removeChild(overlay);
                            reject(new Error('Cookie import cancelled'));
                        });
                        
                        saveButton.addEventListener('click', () => {
                            cookieName = nameInput.value.trim();
                            cookieValue = valueInput.value.trim();
                            
                            if (!cookieName) {
                                alert('Please enter a cookie name');
                                return;
                            }
                            
                            if (!cookieValue) {
                                alert('Please enter a cookie value');
                                return;
                            }
                            
                            document.body.removeChild(overlay);
                            resolve();
                        });
                    });
                    
                    // Set the cookie in Electron's session
                    try {
                        // Try using IPC to set the cookie through the main process
                        // This is more robust than using deprecated remote module
                        if (window.electron && window.electron.ipcRenderer) {
                            // Use IPC to communicate with main process
                            await window.electron.ipcRenderer.invoke('set-cookie', {
                                url: url,
                                name: cookieName,
                                value: cookieValue,
                                domain: domain
                            });
                        } else if (window.electron && window.electron.remote) {
                            // For newer Electron versions with remote
                            const session = window.electron.remote.session.defaultSession;
                            await session.cookies.set({
                                url: url,
                                name: cookieName,
                                value: cookieValue,
                                domain: domain
                            });
                        } else if (window.require) {
                            // For older Electron versions
                            const { remote } = window.require('electron');
                            await remote.session.defaultSession.cookies.set({
                                url: url,
                                name: cookieName,
                                value: cookieValue,
                                domain: domain
                            });
                        } else {
                            // Direct cookie setting via document.cookie (limited, but fallback)
                            document.cookie = `${cookieName}=${cookieValue};domain=${domain};path=/;`;
                        }
                    } catch (cookieError) {
                        console.error('Error setting cookie:', cookieError);
                        // Try a different method if the first one fails
                        try {
                            // Create a temporary invisible browser window to set the cookie
                            const Engine = window.Engine || {};
                            if (Engine.Request && Engine.Request.setCookieInBrowser) {
                                await Engine.Request.setCookieInBrowser(url, cookieName, cookieValue);
                            } else {
                                throw new Error('No fallback cookie method available');
                            }
                        } catch (fallbackError) {
                            throw new Error(`Failed to set cookie: ${cookieError.message}. Fallback also failed: ${fallbackError.message}`);
                        }
                    }
                    
                    alert(`Cookie '${cookieName}' has been imported for ${domain}.\nTry accessing the website connector now.`);
                } catch (error) {
                    console.error('Failed to import cookies:', error);
                    alert('Error importing cookies: ' + error.message);
                }
            }

            /**
             * Download all mangas currently shown in the filtered list, including all their chapters
             */
            async onDownloadAllMangasClick(evt) {
                // Get all currently displayed mangas (filtered)
                let filteredMangas = [];
                const allMangas = this.mangaList || [];
                
                // Apply the filter function to get the currently displayed mangas
                if (this.mangaPattern && this.mangaPattern.length >= 3) {
                    const filterFunction = this.filterMangas(this.mangaPattern);
                    filteredMangas = allMangas.filter(filterFunction);
                } else {
                    filteredMangas = allMangas.slice();
                }

                // Check if there are mangas to download
                if (filteredMangas.length === 0) {
                    await alert('No mangas found in the current view.');
                    return;
                }

                // Confirm with user
                if (!await confirm(`Download ALL chapters from ${filteredMangas.length} manga(s)?\n\nThis will add all available chapters to the download queue.\nDepending on the number of mangas, this operation may take some time.`)) {
                    return;
                }

                // Add status message
                const statusID = this.$.status.addToQueue(`Processing ${filteredMangas.length} manga(s) for download...`);
                
                // Process each manga
                let totalChapters = 0;
                for (let manga of filteredMangas) {
                    // Load chapters for this manga
                    await new Promise((resolve) => {
                        this.$.status.addToQueue(`Loading chapters for: ${manga.title}`);
                        manga.getChapters((error, chapters) => {
                            if (!error && chapters) {
                                // Filter only available chapters
                                const availableChapters = chapters.filter(chapter => chapter.status === 'available');
                                
                                // Add chapters to download queue
                                availableChapters.forEach(chapter => {
                                    Engine.DownloadManager.addDownload(chapter);
                                    totalChapters++;
                                });
                            }
                            resolve();
                        });
                    });
                }

                // Remove status message
                this.$.status.removeFromQueue(statusID);
                
                // Show completion message
                await alert(`Added ${totalChapters} chapters from ${filteredMangas.length} manga(s) to download queue.`);
            }
        }
        window.customElements.define( HakunekoMangas.is, HakunekoMangas );
    </script>

</dom-module>
